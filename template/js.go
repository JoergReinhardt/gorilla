package template

import (
	"bytes"
	"fmt"
	"strings"
	"text/template/parse"
)

// ToJs compiles a set of template trees to JavaScript. Bwahahaha.
func ToJs(treeSet map[string]*parse.Tree, namespace string) (js string, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("%v", r)
		}
	}()
	return new(jsCompiler).compile(treeSet, namespace), nil
}

// ----------------------------------------------------------------------------

// jsCompiler compiles a text/template to JavaScript. Bwahahaha.
//
// Adapted from com.google.template.soy.jssrc.internal.JsCodeBuilder,
// from the Closure Templates library. Copyright 2008 Google Inc.
type jsCompiler struct {
	b                *bytes.Buffer
	indent           string
	outputVars       []string
	outputVarsInited []bool
}

// outputVar returns the current output variable name.
func (c *jsCompiler) outputVar() string {
	if len(c.outputVars) > 0 {
		return c.outputVars[len(c.outputVars)-1]
	}
	panic("output variable name is not set")
}

// outputVarInited returns whether the current output variable is initialized.
func (c *jsCompiler) outputVarInited() bool {
	if len(c.outputVarsInited) > 0 {
		return c.outputVarsInited[len(c.outputVarsInited)-1]
	}
	panic("output variable initialization flag is not set")
}

// pushOutputVar sets a new current output variable name.
func (c *jsCompiler) pushOutputVar(name string) {
	c.outputVars = append(c.outputVars, name)
	c.outputVarsInited = append(c.outputVarsInited, false)
}

// popOutputVar removes the current output variable name. The previous output
// variable becomes the current.
func (c *jsCompiler) popOutputVar() {
	if len(c.outputVars) > 0 {
		c.outputVars = c.outputVars[:len(c.outputVars)-1]
		c.outputVarsInited = c.outputVarsInited[:len(c.outputVarsInited)-1]
	}
}

// initOutputVar appends a full line/statement for initializing the current
// output variable.
func (c *jsCompiler) initOutputVar() {
	if c.outputVarInited() {
		// Nothing to do since it's already initialized.
		return;
	}
	c.writeLine("var ", c.outputVar(), " = new soy.StringBuilder();");
	c.setOutputVarInited()
}

// setOutputVarInited sets that the current output variable has already been
// initialized. This causes initOutputVar and addToOutputVar to not add
// initialization code even on the first use of the variable.
func (c *jsCompiler) setOutputVarInited() {
	if len(c.outputVarsInited) > 0 {
		c.outputVarsInited[len(c.outputVarsInited)-1] = true
	} else {
		panic("output variable is not set")
	}
}

// increaseIndent increases the current indent by two spaces.
func (c *jsCompiler) increaseIndent() {
	c.indent = strings.Repeat(" ", len(c.indent)+2)
}

// decreaseIndent decreases the current indent by two spaces.
func (c *jsCompiler) decreaseIndent() {
	// check out of range?
	c.indent = c.indent[:len(c.indent)-2]
}

// write appends one or more strings to the generated code.
func (c *jsCompiler) write(parts ...string) *jsCompiler {
	for _, v := range parts {
		c.b.WriteString(v)
	}
	return c
}

// writeIndent appends the current indent to the generated code.
func (c *jsCompiler) writeIndent() *jsCompiler {
	c.b.WriteString(c.indent)
	return c
}

// writeLine is equivalent to c.writeIndent().append(part).append("\n").
func (c *jsCompiler) writeLine(parts ...string) *jsCompiler {
	c.writeIndent()
	c.write(parts...)
	c.b.WriteByte('\n')
	return c
}

// writeOutputVarName appends the name of the current output variable.
func (c *jsCompiler) writeOutputVarName() *jsCompiler {
	c.b.WriteString(c.outputVar())
	return c
}

// addToOutputVar appends a line/statement with the given concatenation of the
// given JS expressions saved to the current output variable.
func (c *jsCompiler) addToOutputVar(exprs ...string) {
	b := new(bytes.Buffer)
	for k, v := range exprs {
		if k > 0 {
			b.WriteString(", ")
		}
		b.WriteString(v)
	}
	if c.outputVarInited() {
		// output.append(AAA, BBB);
		c.writeLine(c.outputVar(), ".append(", b.String(), ");")
	} else {
		// var output = new soy.StringBuilder(AAA, BBB);
		c.writeLine("var ", c.outputVar(), " = new soy.StringBuilder(",
			b.String(), ");")
		c.setOutputVarInited()
	}
}

func (c *jsCompiler) compile(treeSet map[string]*parse.Tree, namespace string) string {
	c.b = new(bytes.Buffer)
	c.writeLine("// Code generated by gorilla/template.")
	c.writeLine("// Please don't edit this file by hand.")
	c.writeLine()
	ns := ""
	namespace = strings.Trim(namespace, ".")
	for _, name := range strings.Split(namespace, ".") {
		if name != "" {
			if ns != "" {
				ns += "."
			}
			ns += name
			c.writeLine(fmt.Sprintf(
				"if (typeof %s == 'undefined') { var %s = {}; }", ns, ns))
		}
	}
	c.writeLine()
	if namespace != "" {
		namespace += "."
	}
	for name, tree := range treeSet {
		c.pushOutputVar("output")
		c.writeLine(fmt.Sprintf("%s%s = function(opt_data, opt_sb) {",
			namespace, name))
		c.increaseIndent()
		//c.writeLine("  var output = opt_sb || new soy.StringBuilder();")
		for _, node := range tree.Root.Nodes {
			c.visit(node)
		}
		//b.writeLine("  if (!opt_sb) {\n    return output.toString();\n  }")
		c.decreaseIndent()
		c.writeLine("}")
		c.popOutputVar()
	}
	return c.b.String()
}

// WIP
func (c *jsCompiler) visit(node parse.Node) visitor {
	if node == nil {
		return nil
	}
	switch n := node.(type) {
	case *parse.TextNode:
		c.writeLine("'", string(n.Text), "'")
	case *parse.ActionNode:
	}
	return nil
}

// ----------------------------------------------------------------------------

// A visitor's visit method is invoked for each node encountered by walk.
// If the returned visitor is not nil, walk visits each of the children
// of node using it, followed by a call of visit(nil).
//
// Borrowed from go/ast.
type visitor interface {
	visit(parse.Node) visitor
}

// walk traverses the parse tree in depth-first order. It starts by calling
// v.visit(node); node must not be nil. If the visitor returned is not nil,
// walk is invoked recursively for each of the non-nil children of node,
// followed by a call of v.visit(nil).
//
// Borrowed from go/ast.
//
// WIP
func walk(v visitor, node parse.Node) {
	if v = v.visit(node); v == nil {
		return
	}
	switch n := node.(type) {
	case *parse.TextNode:
		// nothing to do
	case *parse.ActionNode:
		// ...
	case *parse.BoolNode:
		// nothing to do
	case *parse.CommandNode:
		// ...
	case *parse.DotNode:
		// ...
	case *parse.FieldNode:
		// ...
	case *parse.IdentifierNode:
		// ...
	case *parse.IfNode:
		// ...
	case *parse.ListNode:
		// ...
	case *parse.NumberNode:
		// nothing to do
	case *parse.PipeNode:
		// ...
	case *parse.RangeNode:
		// ...
	case *parse.StringNode:
		// ...
	case *parse.TemplateNode:
		// ...
	case *parse.VariableNode:
		// ...
	case *parse.WithNode:
		// ...
	default:
		panic(fmt.Errorf("unexpected node type %T", n))
	}
	v.visit(nil)
}
